/*
 * task_handler.c
 *
 *  Created on: May 28, 2021
 *      Author: minia
 */
#include "main.h"
int extract_command(command_t *cmd);
void process_command(command_t *cmd);
char* msg_inv = "Invalid option\n";
void menu_task(void *param) {
	uint32_t cmd_addr;
	int option;
	const char* msg_menu = "=======================\n"
						   "       Menu            \n"
						   "=======================\n"
						   "   LED effect    ---> 0\n "
						   "   Date and time ---> 1\n "
						   "   Exit          ---> 2\n "
			               "Enter your choice here : ";
	while (1) {
		xQueueSend(q_print, &msg_menu, portMAX_DELAY);
		xTaskNotifyWait(0, 0, &cmd_addr, portMAX_DELAY);
		cmd = (command_t*)cmd_addr;
		if(cmd->len == 1) {
			option = cmd->payload[0] - 48;
			switch(option) {
				case 0:
					curr_state = sLedEffect;
					xTaskNotify(handle_led_task, 0, eNoAction);
				break;

				case 1:
					curr_state = sRtcMenu;
					xTaskNotify(handle_rtc_task, 0, eNoAction);
				break;

				case 2:
					curr_state = sRtcMenu;
					xTaskNotify(handle_rtc_task, 0, eNoAction);
				break;
			}
		} else {
			xQueueSend(q_print, &msg_inv, portMAX_DELAY);
		}
	}
}

void led_task(void *param) {
	while (1) {

	}
}

void rtc_task(void *param) {
	while (1) {

	}
}

void print_task(void *param) {
	while (1) {

	}
}

void cmd_handler_task(void *param) {
	BaseType_t ret;
	command_t cmd;
	while (1) {
		ret = xTaskNotifyWait(0, 0, NULL, portMAX_DELAY);
		if(ret == pdTRUE) {
			process_command(&cmd);
		}

	}
}

void process_command(command_t *cmd) {
	extract_command(cmd);

	switch(curr_state)
	{
		case sMainMenu:
			xTaskNotify(handle_menu_task, (uint32_t)cmd, eSetValueWithOverwrite);
		break;

		case sLedEffect:
			xTaskNotify(handle_led_task, (uint32_t)cmd, eSetValueWithOverwrite);
		break;

		case sRtcMenu:
		case sRtcTimeConfig:
		case sRtcDateConfig:
		case sRtcReport:
			xTaskNotify(handle_rtc_task, (uint32_t)cmd, eSetValueWithOverwrite);
		break;

	}
}

int extract_command(command_t *cmd)
{
	uint8_t item;
	BaseType_t status;
	uint8_t i = 0;
	status = uxQueueMessagesWaiting(q_data);
	if(!status) {
		return -1;
	}

	do {
		status = xQueueReceive(q_data, &item, 0);
		if(status == pdTRUE) cmd->payload[i++] = item;
	} while(item != '\n');
	cmd->payload[i-1] = '\n';
	cmd->len = i-1;
	return 0;
}



